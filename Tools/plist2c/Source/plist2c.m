/*	plist2c.m
	
	Command line tool which turns a property list file into a C file defining an array (called
	kFileName) containing said property list in binary plist format. This is used to embed property
	lists into command line tools without relying on external files.
	
	It lacks robustness in generating the name of the array - it is assumed that the input file
	name, with any extension deleted, will be a C identifier.
*/

#import <Foundation/Foundation.h>


static NSString *ReadPath(const char *path);

static void ProcessFile(NSString *inPath, NSString *outPath);


int main (int argc, const char * argv[])
{
	[[NSAutoreleasePool alloc] init];
	
	if (argc < 3)
	{
		fprintf(stderr, "You must specify at least one input file and an output path.");
		return EXIT_FAILURE;
	}
	
	NSString *outPath = ReadPath(argv[argc - 1]);
	
	for (int i = 1; i < argc - 1; ++i)
	{
		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
		
		ProcessFile(ReadPath(argv[i]), outPath);
		
		[pool release];
	}
	
    return 0;
}


static NSString *ReadPath(const char *path)
{
	NSString *result = [NSString stringWithUTF8String:path];
	if ([result hasPrefix:@"/"]) result = [result stringByStandardizingPath];
	else if ([result hasPrefix:@"~"]) result = [result stringByExpandingTildeInPath];
	else result = [[[NSFileManager defaultManager] currentDirectoryPath] stringByAppendingPathComponent:result];
	result = [result stringByStandardizingPath];
	
	if (result == nil)
	{
		fprintf(stderr, "Could not interpret \"%s\" as a path.", path);
		exit(EXIT_FAILURE);
	}
	
	return result;
}


static void ProcessFile(NSString *inPath, NSString *outPath)
{
	NSData					*data;
	id						plist;
	NSString				*errStr = nil;
	unsigned				i, length;
	const uint8_t			*bytes;
	const char				*fileName;
	FILE					*outFile;
	unsigned				lineChars = 0;
	const char				*inFileDisplayName;
	uint8_t					byte;
	
	inFileDisplayName = [[inPath lastPathComponent] UTF8String] ?: "(null path)";
	
	data = [NSData dataWithContentsOfFile:inPath];
	if (nil == data)
	{
		fprintf(stderr, "Error: Could not load file %s.\n", inFileDisplayName);
		return;
	}
	
	// We read the plist and convert it to binary, because embedding an XML or text plist in code seems silly.
	// This has the side-effect of ensuring the file is actually a property list.
	plist = [NSPropertyListSerialization propertyListFromData:data mutabilityOption:NSPropertyListImmutable format:NULL errorDescription:&errStr];
	if (nil == plist)
	{
		fprintf(stderr, "Error: Could not convert file %s to property list: %s.\n", inFileDisplayName, [errStr UTF8String] ?: "unknown error");
		return;
	}
	
	data = [NSPropertyListSerialization dataFromPropertyList:plist format:NSPropertyListBinaryFormat_v1_0 errorDescription:&errStr];
	if (nil == data)
	{
		fprintf(stderr, "Error: Could not convert plist representation of file %s to binary property list format: %s.\n", inFileDisplayName, [errStr UTF8String] ?: "unknown error");
		return;
	}
	
	NSString *baseName = [[inPath lastPathComponent] stringByDeletingPathExtension];
	fileName = [baseName UTF8String];
	bytes = [data bytes];
	length = [data length];
	
	// Write header file
	NSString *hPath = [[outPath stringByAppendingPathComponent:baseName] stringByAppendingPathExtension:@"h"];
	outFile = fopen([hPath UTF8String], "wb+");
	if (NULL == outFile)
	{
		fprintf(stderr, "Error: Could not open output header file %s.\n", [hPath UTF8String] ?: "(null path)");
		return;
	}
	
	fprintf(outFile, "/* File is autogenerated from %s by plist2c. */\n\n\n", inFileDisplayName);
	fprintf(outFile, "#ifndef INCLUDED_%s_h\n", fileName);
	fprintf(outFile, "#define INCLUDED_%s_h\n\n", fileName);
	fprintf(outFile, "#define k%sLength %u\n", fileName, length);
	fprintf(outFile, "extern unsigned char k%s[k%sLength];\n\n", fileName, fileName);
	fprintf(outFile, "#endif /* INCLUDED_%s_h */\n", fileName);
	fclose(outFile);
	
	NSString *cPath = [[outPath stringByAppendingPathComponent:baseName] stringByAppendingPathExtension:@"c"];
	outFile = fopen([cPath UTF8String], "wb+");
	if (NULL == outFile)
	{
		fprintf(stderr, "Error: Could not open output C file %s.\n", [cPath UTF8String] ?: "(null path)");
		return;
	}
	
	fprintf(outFile, "/* File is autogenerated from %s by plist2c. */\n\n\n", inFileDisplayName);
	fprintf(outFile, "#include \"%s.h\"\n\n\n", fileName);
	fprintf(outFile, "unsigned char k%s[k%sLength] =\n\t\"", fileName, fileName);
	
	for (i = 0; i != length; ++i)
	{
		if (70 <= lineChars)
		{
			fprintf(outFile, "\"\n\t\"");
			lineChars = 0;
		}
		
		byte = bytes[i];
		if ('\\' == byte)
		{
			fprintf(outFile, "\\\\");
			lineChars += 2;
		}
		else if ('\?' == byte)
		{
			fprintf(outFile, "\\?");
			lineChars += 2;
		}
		else if ('\"' == byte)
		{
			fprintf(outFile, "\\\"");
			lineChars += 2;
		}
		else if ('\'' == byte)
		{
			fprintf(outFile, "\\\'");
			lineChars += 2;
		}
		else if ('\a' == byte)
		{
			fprintf(outFile, "\\a");
			lineChars += 2;
		}
		else if ('\b' == byte)
		{
			fprintf(outFile, "\\b");
			lineChars += 2;
		}
		else if ('\f' == byte)
		{
			fprintf(outFile, "\\f");
			lineChars += 2;
		}
		else if ('\n' == byte)
		{
			fprintf(outFile, "\\n");
			lineChars += 2;
		}
		else if ('\r' == byte)
		{
			fprintf(outFile, "\\r");
			lineChars += 2;
		}
		else if ('\t' == byte)
		{
			fprintf(outFile, "\\t");
			lineChars += 2;
		}
		else if ('\v' == byte)
		{
			fprintf(outFile, "\\v");
			lineChars += 2;
		}
		else if (' ' <= byte && byte < 128)
		{
			fprintf(outFile, "%c", byte);
			++lineChars;
		}
		else
		{
			// Two quotes are used to force end of escape sequence
			if (64 <= lineChars)
			{
				fprintf(outFile, "\\x%.2X\"\n\t\"", byte);
				lineChars = 0;
			}
			else
			{
				fprintf(outFile, "\\x%.2X\"\"", byte);
				lineChars += 6;
			}
		}
	}
	
	fprintf(outFile, "\";\n");
	
	fclose(outFile);
}
